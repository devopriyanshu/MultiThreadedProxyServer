<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Proxy Server Architecture & Flow</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }
      .header {
        background: linear-gradient(135deg, #2c3e50, #34495e);
        color: white;
        padding: 30px;
        text-align: center;
      }
      .header h1 {
        margin: 0;
        font-size: 2.5em;
        font-weight: 300;
      }
      .section {
        padding: 30px;
        border-bottom: 1px solid #eee;
      }
      .section:last-child {
        border-bottom: none;
      }
      .section h2 {
        color: #2c3e50;
        font-size: 1.8em;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 3px solid #3498db;
      }
      .diagram-container {
        background: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        margin: 20px 0;
        border: 1px solid #e9ecef;
      }
      .architecture-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        margin: 20px 0;
      }
      .component {
        background: white;
        border-radius: 8px;
        padding: 15px;
        border: 2px solid #3498db;
        text-align: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }
      .component:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
      }
      .component h3 {
        margin: 0 0 10px 0;
        color: #2c3e50;
        font-size: 1.2em;
      }
      .component p {
        margin: 0;
        font-size: 0.9em;
        color: #666;
      }
      .flow-step {
        display: flex;
        align-items: center;
        margin: 15px 0;
        padding: 15px;
        background: white;
        border-radius: 8px;
        border-left: 4px solid #3498db;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .step-number {
        background: #3498db;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 15px;
        flex-shrink: 0;
      }
      .step-content {
        flex: 1;
      }
      .step-title {
        font-weight: bold;
        color: #2c3e50;
        margin-bottom: 5px;
      }
      .step-description {
        color: #666;
        font-size: 0.9em;
      }
      .arrow {
        text-align: center;
        font-size: 2em;
        color: #3498db;
        margin: 10px 0;
      }
      .cache-diagram {
        display: flex;
        justify-content: space-around;
        align-items: center;
        margin: 20px 0;
      }
      .cache-node {
        background: #e8f5e8;
        border: 2px solid #4caf50;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        min-width: 80px;
      }
      .cache-arrow {
        font-size: 1.5em;
        color: #4caf50;
      }
      .thread-pool {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        margin: 20px 0;
      }
      .thread {
        background: #fff3cd;
        border: 2px solid #ffc107;
        border-radius: 6px;
        padding: 8px;
        text-align: center;
        font-size: 0.8em;
        font-weight: bold;
      }
      .thread.active {
        background: #d4edda;
        border-color: #28a745;
      }
      .code-snippet {
        background: #2d3748;
        color: #e2e8f0;
        padding: 15px;
        border-radius: 8px;
        font-family: "Monaco", "Consolas", monospace;
        font-size: 0.9em;
        margin: 10px 0;
        overflow-x: auto;
      }
      .highlight {
        background: #ffeaa7;
        padding: 2px 4px;
        border-radius: 3px;
        font-weight: bold;
      }
      .warning {
        background: #ffebee;
        border: 1px solid #f44336;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
      }
      .warning h4 {
        color: #d32f2f;
        margin: 0 0 10px 0;
      }
      .success {
        background: #e8f5e8;
        border: 1px solid #4caf50;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
      }
      .success h4 {
        color: #2e7d32;
        margin: 0 0 10px 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Multithreaded Proxy Server</h1>
        <p>Complete Architecture & Flow Analysis</p>
      </div>

      <div class="section">
        <h2>üèóÔ∏è System Architecture Overview</h2>
        <div class="architecture-grid">
          <div class="component">
            <h3>üåê Client Layer</h3>
            <p>
              Multiple clients sending HTTP requests to proxy server on port
              8080
            </p>
          </div>
          <div class="component">
            <h3>üîÑ Proxy Server</h3>
            <p>
              Main process handling connections with thread pool and caching
            </p>
          </div>
          <div class="component">
            <h3>üñ•Ô∏è Remote Servers</h3>
            <p>Target web servers that proxy fetches content from</p>
          </div>
          <div class="component">
            <h3>üßµ Thread Pool</h3>
            <p>Up to 400 concurrent threads managed by semaphore</p>
          </div>
          <div class="component">
            <h3>üíæ LRU Cache</h3>
            <p>200MB cache with 10MB max element size using linked list</p>
          </div>
          <div class="component">
            <h3>üîí Synchronization</h3>
            <p>Semaphores for connection control, mutex for cache protection</p>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>üìä Detailed System Flow</h2>
        <div class="diagram-container">
          <div class="flow-step">
            <div class="step-number">1</div>
            <div class="step-content">
              <div class="step-title">Server Initialization</div>
              <div class="step-description">
                ‚Ä¢ Create proxy socket on specified port<br />
                ‚Ä¢ Initialize semaphore (MAX_CLIENTS = 400)<br />
                ‚Ä¢ Initialize cache mutex lock<br />
                ‚Ä¢ Start listening for connections
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">2</div>
            <div class="step-content">
              <div class="step-title">Connection Acceptance</div>
              <div class="step-description">
                ‚Ä¢ Main thread accepts client connections in infinite loop<br />
                ‚Ä¢ Extract client IP and port information<br />
                ‚Ä¢ Store socket descriptor in Connected_socketId[] array<br />
                ‚Ä¢ Create new thread for each client
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">3</div>
            <div class="step-content">
              <div class="step-title">Thread Synchronization</div>
              <div class="step-description">
                ‚Ä¢ New thread calls sem_wait() on semaphore<br />
                ‚Ä¢ If semaphore count > 0: thread proceeds<br />
                ‚Ä¢ If semaphore count = 0: thread blocks until slot available<br />
                ‚Ä¢ This limits concurrent connections to MAX_CLIENTS
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">4</div>
            <div class="step-content">
              <div class="step-title">HTTP Request Reception</div>
              <div class="step-description">
                ‚Ä¢ Receive data from client socket into buffer<br />
                ‚Ä¢ Loop until complete request received (look for
                \\r\\n\\r\\n)<br />
                ‚Ä¢ Handle partial requests arriving in multiple packets<br />
                ‚Ä¢ Create copy of request for cache key
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">5</div>
            <div class="step-content">
              <div class="step-title">Cache Lookup</div>
              <div class="step-description">
                ‚Ä¢ Acquire cache mutex lock<br />
                ‚Ä¢ Search linked list for matching URL<br />
                ‚Ä¢ If found: update LRU timestamp and return cached response<br />
                ‚Ä¢ If not found: proceed to remote server request
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">6</div>
            <div class="step-content">
              <div class="step-title">Request Parsing & Validation</div>
              <div class="step-description">
                ‚Ä¢ Parse HTTP request using ParsedRequest_parse()<br />
                ‚Ä¢ Validate HTTP method (only GET supported)<br />
                ‚Ä¢ Check HTTP version (1.0/1.1 accepted)<br />
                ‚Ä¢ Ensure host, path, and version are present
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">7</div>
            <div class="step-content">
              <div class="step-title">Remote Server Connection</div>
              <div class="step-description">
                ‚Ä¢ Resolve hostname using gethostbyname()<br />
                ‚Ä¢ Create new socket to remote server<br />
                ‚Ä¢ Connect to remote server on appropriate port<br />
                ‚Ä¢ Modify request headers (add Connection: close, Host header)
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">8</div>
            <div class="step-content">
              <div class="step-title">
                Request Forwarding & Response Streaming
              </div>
              <div class="step-description">
                ‚Ä¢ Send modified request to remote server<br />
                ‚Ä¢ Receive response in chunks (4KB buffers)<br />
                ‚Ä¢
                <span class="highlight"
                  >Simultaneously forward to client AND cache</span
                ><br />
                ‚Ä¢ Dynamically expand cache buffer as needed
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">9</div>
            <div class="step-content">
              <div class="step-title">Cache Storage</div>
              <div class="step-description">
                ‚Ä¢ Acquire cache mutex lock<br />
                ‚Ä¢ Check if response size exceeds MAX_ELEMENT_SIZE<br />
                ‚Ä¢ Evict LRU elements until sufficient space available<br />
                ‚Ä¢ Add new cache element at head of linked list
              </div>
            </div>
          </div>

          <div class="arrow">‚Üì</div>

          <div class="flow-step">
            <div class="step-number">10</div>
            <div class="step-content">
              <div class="step-title">Connection Cleanup</div>
              <div class="step-description">
                ‚Ä¢ Close remote server socket<br />
                ‚Ä¢ Close client socket<br />
                ‚Ä¢ Free allocated memory buffers<br />
                ‚Ä¢ Release semaphore with sem_post()<br />
                ‚Ä¢ Thread terminates
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>üîß Thread Pool Management</h2>
        <div class="diagram-container">
          <h3>Semaphore-Based Connection Control</h3>
          <div class="thread-pool">
            <div class="thread active">Thread 1<br />ACTIVE</div>
            <div class="thread active">Thread 2<br />ACTIVE</div>
            <div class="thread active">Thread 3<br />ACTIVE</div>
            <div class="thread">Thread 4<br />WAITING</div>
            <div class="thread active">Thread 5<br />ACTIVE</div>
            <div class="thread">Thread 6<br />WAITING</div>
            <div class="thread active">Thread 7<br />ACTIVE</div>
            <div class="thread">Thread 8<br />WAITING</div>
          </div>
          <div class="code-snippet">
            sem_t seamaphore; // Counting semaphore sem_init(&seamaphore, 0,
            MAX_CLIENTS); // Initialize to 400 // In each thread:
            sem_wait(&seamaphore); // Acquire slot (blocks if full) // ...
            handle client request ... sem_post(&seamaphore); // Release slot
          </div>
        </div>
      </div>

      <div class="section">
        <h2>üíæ Cache Architecture (LRU Implementation)</h2>
        <div class="diagram-container">
          <h3>Linked List Structure</h3>
          <div class="cache-diagram">
            <div class="cache-node">
              <strong>HEAD</strong><br />
              Most Recent<br />
              time: 1640995200
            </div>
            <div class="cache-arrow">‚Üí</div>
            <div class="cache-node">
              <strong>Node 2</strong><br />
              time: 1640995100
            </div>
            <div class="cache-arrow">‚Üí</div>
            <div class="cache-node">
              <strong>Node 3</strong><br />
              time: 1640995000
            </div>
            <div class="cache-arrow">‚Üí</div>
            <div class="cache-node">
              <strong>TAIL</strong><br />
              Least Recent<br />
              time: 1640994900<br />
              <span style="color: red">[EVICT]</span>
            </div>
          </div>

          <h3>Cache Operations</h3>
          <div class="success">
            <h4>Cache Hit Process:</h4>
            1. Acquire mutex lock<br />
            2. Linear search through linked list<br />
            3. Update lru_time_track to current time<br />
            4. Release mutex lock<br />
            5. Send cached response to client
          </div>

          <div class="warning">
            <h4>Cache Miss Process:</h4>
            1. Forward request to remote server<br />
            2. Stream response to client while buffering<br />
            3. Acquire mutex lock for cache addition<br />
            4. Remove LRU elements until space available<br />
            5. Add new element at head<br />
            6. Release mutex lock
          </div>

          <div class="code-snippet">
            struct cache_element { char* data; // HTTP response int len; // Data
            length char* url; // Complete HTTP request (key) time_t
            lru_time_track; // Last access timestamp cache_element* next; //
            Next element }; // Cache limits: #define MAX_SIZE 200*(1<<20) //
            200MB total cache #define MAX_ELEMENT_SIZE 10*(1<<20) // 10MB per
            element
          </div>
        </div>
      </div>

      <div class="section">
        <h2>üîÑ Request Processing States</h2>
        <div class="diagram-container">
          <div class="architecture-grid">
            <div
              class="component"
              style="background: #e3f2fd; border-color: #2196f3"
            >
              <h3>üü¶ WAITING</h3>
              <p>Thread blocked on semaphore until connection slot available</p>
            </div>
            <div
              class="component"
              style="background: #fff3e0; border-color: #ff9800"
            >
              <h3>üüß RECEIVING</h3>
              <p>Reading complete HTTP request from client socket</p>
            </div>
            <div
              class="component"
              style="background: #f3e5f5; border-color: #9c27b0"
            >
              <h3>üü™ CACHE_LOOKUP</h3>
              <p>Searching cache with mutex protection</p>
            </div>
            <div
              class="component"
              style="background: #e8f5e8; border-color: #4caf50"
            >
              <h3>üü© CACHE_HIT</h3>
              <p>Serving response directly from cache</p>
            </div>
            <div
              class="component"
              style="background: #ffebee; border-color: #f44336"
            >
              <h3>üü• REMOTE_FETCH</h3>
              <p>Connecting to remote server and streaming response</p>
            </div>
            <div
              class="component"
              style="background: #fce4ec; border-color: #e91e63"
            >
              <h3>üü™ CACHING</h3>
              <p>Adding response to cache with LRU eviction</p>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>‚ö° Performance Characteristics</h2>
        <div class="architecture-grid">
          <div class="success">
            <h4>Strengths:</h4>
            ‚Ä¢ <strong>Low Latency:</strong> Streaming responses while caching<br />
            ‚Ä¢ <strong>High Concurrency:</strong> 400 simultaneous connections<br />
            ‚Ä¢ <strong>Memory Efficient:</strong> Fixed cache size with LRU
            eviction<br />
            ‚Ä¢ <strong>Thread Safe:</strong> Proper synchronization primitives
          </div>
          <div class="warning">
            <h4>Bottlenecks:</h4>
            ‚Ä¢ <strong>Cache Search:</strong> O(n) linear search through linked
            list<br />
            ‚Ä¢ <strong>Cache Eviction:</strong> O(n) to find LRU element<br />
            ‚Ä¢ <strong>Serialized Cache Access:</strong> Mutex blocks all cache
            operations<br />
            ‚Ä¢ <strong>Memory Allocation:</strong> Frequent malloc/free
            operations
          </div>
        </div>
      </div>

      <div class="section">
        <h2>üîß Error Handling & Edge Cases</h2>
        <div class="diagram-container">
          <div class="flow-step">
            <div class="step-number">‚ö†Ô∏è</div>
            <div class="step-content">
              <div class="step-title">Connection Errors</div>
              <div class="step-description">
                DNS resolution failures, connection timeouts, socket creation
                errors ‚Üí Send HTTP 500 Internal Server Error
              </div>
            </div>
          </div>
          <div class="flow-step">
            <div class="step-number">‚ö†Ô∏è</div>
            <div class="step-content">
              <div class="step-title">Malformed Requests</div>
              <div class="step-description">
                Invalid HTTP syntax, missing headers, unsupported methods ‚Üí Send
                HTTP 400 Bad Request or 501 Not Implemented
              </div>
            </div>
          </div>
          <div class="flow-step">
            <div class="step-number">‚ö†Ô∏è</div>
            <div class="step-content">
              <div class="step-title">Resource Exhaustion</div>
              <div class="step-description">
                Memory allocation failures, file descriptor limits ‚Üí Graceful
                degradation with error responses
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
